# Клавиатура IBM PC. Использование прерываний

## Задание на лабораторную работу

1. Разработать, написать и отладить программу управления перемещением символа ("*") в пределах заданного на экране окна. Для управления использовать функциональные клавиши Fl - F12. Для ввода использовать стандартные функции языка C++. Сохранить отлаженную программу.
2. Изменить программу, заменив стандартные функции библиотеки C++ своими. Для написания функций используйте заданное прерывание, если его возможностей достаточно. Если его возможностей недостаточно, то замените его по своему усмотрению. Сохраните отлаженную программу.
3. Отлаженные программы предъявить преподавателю.

№ варианта | X1 | Y1 | X2 | Y2 | Вид движения | Клавиши управления | Номер прерывания
:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:
11 | 20 | 10 | 60 | 20 | Постоянное | F3, F4 | INT 21h

### Краткие сведения о подсистеме ввода информации с клавиатуры, используемых прерываниях, буфере клавиатуры и функциях обслуживания ввода с клавиатуры

Подавляющее большинство программ выполняют ввод информации с клавиатуры. Ввод информации в компьютер может быть выполнен на трех уровнях: обращением к функциям `MS-DOS`; обращением к функциям `BIOS`; физическим доступом к аппаратным средствам.
Ввод информации на уровне `MS-DOS` позволяет "пропустить" клавиатурный ввод через инсталлируемые драйверы, обеспечивает отслеживание нажатия комбинации клавиш `Ctrl-C` (Ctrl-Break), стандартную для MS-DOS обработку ошибок.
Доступ к клавиатуре на уровне `BIOS` позволяет программе отслеживать нажатие всех, а не только символьных клавиш, выполнять управление аппаратурой клавиатуры и пр. Интерфейсом `Turbo С` с `BIOS` является функция `bioskey()`.
Непосредственный доступ к буферу клавиатуры резко повышает производительность программы. В некоторых случаях необходима имитация нажатий клавиш клавиатуры с записью кодов непосредственно в буфер. При этом физически нажатия клавиш не происходят. Так строятся многие демонстрационные программы, которые открывают или закрывают окна меню, выполняют необходимый выбор, показывают работу программы в "автоматическом" режиме и т.п. На том же самом принципе имитации нажатий клавиш построены программы, способные переносить одним нажатием клавиши целые куски текста из одной программы в любой текстовый редактор. Примером такой программы является входящая в `Turbo С` резидентная Help-система `THELP.COM`.
Клавиатура персонального компьютера содержит специальный встроенный микропроцессор. Он при каждом нажатии и отпускании клавиши определяет ее порядковый номер и помещает его в порт `60h` специальной электронной схемы - программируемого периферийного интерфейса (ППИ). Далее этот код будем называть скэн-кодом. Скэн-код в первых 7 битах содержит порядковый номер нажатой клавиши, а восьмой бит равен 0, если клавиша была нажата (прямой скэн-код), и равен 1, если клавиша была отпущена (обратный скэн-код). Когда скэн-код записан в порт `60h`, схема ППИ выдает сигнал "подтверждения", уведомляя микропроцессор клавиатуры о принятии кода.
Если клавиша остается нажатой дольше некоторого времени задержки `(delay value)`, микропроцессор клавиатуры начинает генерировать с заданной частотой `(typematic rate)` прямой скэн-код нажатой клавиши. Значения задержки и частоты повторения могут устанавливаться в нужные значения либо через порты клавиатуры, либо через функцию `АН = 03h` прерывания 16h BIOS. Когда скэн-код принят схемой ППИ, аппаратура компьютера генерирует аппаратное прерывание с номером 9.
Стандартный обработчик прерывания 9 - это программа, входящая в состав `BIOS` `(BIOS ISR)`. `BIOS ISR` анализирует скэн-код и по специальным правилам преобразует его. Отметим, что по скэн-коду всегда можно установить, вследствие чего `ISR` получила управление: из-за нажатия или из-за отпускания клавиши.

## Алгоритмы

Для того, чтобы движение символа было постоянным используется два вложенных цикла `while` (с конструкцией `switch-case`): первая, чтобы программа выполнялась до нажатия кнопки `ESC`, вторая – для непрерывного движения символа ('`*`') с условием нажатия кнопки, определяющая противоположное направление.

```C++
while(c != 27) // пока не нажали ESC
{
    switch(c) // от нажатой клавиши
    {
    case 75:    // <-
    case 61:    // F3
        while(c != 77 || c != 61)
        {
        // сдвиг во одну сторону
        }
        break;
    case 77:    // ->
    case 62:    // F4
        while(c != 75 || c != 62)
        {
        //сдвиг в другую сторону
        }
        break;
        default:
        break;
}
```

В программе кроме функциональных клавиш `F3` и `F4`, предусмотрена управление символом клавишами из набора "стрелка вправо" и "стрелка влево".

Для улавливания нажатия кнопок в первой части лабораторной работы была использована функция `bioskey()` из библиотеки `dos.h`. Данная функция при аргументе 0 возвращает `ASCII` код нажатой клавиши, а при аргументе 1, проверяет на нажатие кнопок вообще и возвращает 0 при бездействии клавиатуры.
Во второй части лабораторной работы была использована собственная реализация проверки на нажатие и возвращение `ASCII` кода нажатой клавиши.
Ниже представлена реализация вышеупамянутой функции

```C++
char keyIsPressed(int x)
{
    union REGS r;
    if (x==1) {    // какая кнопка нажата
        r.h.ah = 0x0B;  
        int86(0x21, &r, &r); 
        return r.h.al;
    }
    if(x==0) {  // проверка на нажатие кнопок вообще
        r.h.ah = 0x7
        int86(0x21, &r, &r);    //int86(номер прерывания,откуда,куда)
        return r.h.al;
    }
    return 0;
}
```
