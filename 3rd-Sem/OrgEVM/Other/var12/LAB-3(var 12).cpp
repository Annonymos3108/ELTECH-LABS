//  работа с видеосистемой в графическом режиме
#include "stdio.h"
#include "conio.h"
#include "math.h"
#include "dos.h"
#include "graphics.h"
#include "iostream.h"
#include "stdlib.h"
#include "windows.h"
#include "time.h" 

int Xmax, Ymax, X0, X1, Y0, Y1, GrDr, GrM, NormedResult[500]; // глобальные переменные, смысл которых описан ниже
// Result[500]- массив для хранения значений функции по каждому аргументу х, (когда Пи2 <= x <= 8Пи)
float Result[500], Rmax=0.; 

// Формирование массива значений отображаемой функции
void RESULTofFX(int N) // N- количество точек по х-у, это длина оси х в пикселях
{	
	double x, dx=8.*M_PI/N;	// промежуточная переменная х и конечный диапазон 8Пи
	int i;	// итератор цикла for, нельзя сделать внутри так, как идет переопределение х с double на int
	for (i=0, x=M_PI/2.; i<N; i++, x+=dx) // пока не дошли до конца оси х (х макс) в каждой итерации идем на один пиксель вперед
	{
		Result[i]=(float)(pow(sin(x),3)-pow(cos(x),2));  // сама функция, значение функции в каждой точке сохраняем в массив
		if(Rmax<Result[i]) Rmax=Result[i]; // определяем макс значение функции в ходе расчета значениий. После оканчания цикла
    }										// в Rmax будет максимум функции
}


// Программа вывода графика функции на экран
int main()
{
	int i, N;
	clrscr();                         // Очистка экрана
	gotoxy(13,10);					// переход на конкретную точку в окне по координатам х у
	cprintf("Press any key...");
	getch();                        // Ожидаем нажатия клавиши...
	detectgraph(&GrDr,&GrM);        // Открыли графичесий режим
	initgraph(&GrDr,&GrM,"..//BORLANDC//BGI"); // Расположение драйверов BGI
	//setcolor(0);	// цвет текста 
	setbkcolor(0);  // цвет фона консоли
	
	/*
	коды цветов
	BLACK			черный	 			0 
	BLUE 			синий 				1
	GREEN 			зеленый 			2 
	CYAN 			сине-зеленый 		3 
	RED 			красный				4 
	MAGENTA 		красно-синий 		5
	BROWN	 		коричневый 			6
	LIGHTGRAY 		светло-серый 		7 
	DARKGRAY 	 	темно-серый 		8 
	LIGHTBLUE 	 	ярко-синий 			9 
	LIGHTGREEN		ярко-зеленый		10
	LIGHTCYAN	  	яркий сине-зеленый	11
	LIGHTRED 		ярко-красный 		12 
	LIGHTMAGENTA	яркий красно-синий	13
	YELLOW	 		желтый	 			14
	WHITE  			белый 				15
	*/
	
	Xmax=getmaxx();  // получаем размеры экрана, и так как отчет по умолчанию идет с левого верхнего угла т.е. там точка 0,0
	Ymax=getmaxy(); // получили размеры экрана
	// поворачиваем так чтобы Х0, У0 было в левом нижнем углу, потому что так привычнее и расчеты приблизительно представимы
	
	X0=40;          Y0=Ymax-200;     // Левый нижний угол графика
	X1=Xmax-200;     Y1=200;          // Правый верхний угол графика
	
	N = X1-X0;      // Количество точек по оси X
	
	char Ox[9][6] = {" ", "Pi",  "2Pi", "3Pi",  "4Pi",  "5Pi", "6Pi", "7Pi", "8Pi"}; // метки координатной оси х
	setlinestyle(0,1,3);    // параметры линий, 0 - стиль, 1 - цвет, 3 - толщина  // дополнительно в методике стр 43
	outtextxy(125, 30, "f(x)=sin^3(x)-cos^2(x) на отрезке от Pi/2 до 8Pi");	// п
	outtextxy (200, 50, "Максимальное значение функции 1");
	RESULTofFX(N);                    // Вычислили значения функции
	for (i=0;i<N;i++)                // Нормируем все значения функции
		NormedResult[i]=Y0-(int)(Result[i]/Rmax*(float)(Y0-Y1));
	setlinestyle(0,1,1);         // Рисуем координатные оси // задаем стиль линии
	line(X0, Y0+130, X0, Y1);	// ось у
	line(X0, Y0, X1+2, Y0);     // ось х
	outtextxy(X0+3,Y1,"f(x)");    // Помечаем оси... y - как функция f(x)
	outtextxy(X1+20,Y0+1,"x");	 // .. х
	outtextxy(X0-10, Y0-10, "0");	// отмечаем 0
	outtextxy(X0-10, Y1, "1");		// максимум функции
	outtextxy(X0-18, Y0+125, "-1");		// минимум функции
	
	for (i=1; i<9; i++)	//Рисуем метки и подписи на оси Х
	{
		line(X0+(int)(N/8)*i, Y0-3, X0+(int)(N/8)*i, Y0+3); //Метки
		outtextxy(X0+(int)(N/8)*i-10, Y0+5, Ox[i]); 	//Подписи
	};
	// что твориться в строке метки? X0+(int)(N/8)*i -- берем начало координат и к нему плюсуем длину координат х 
	// разделенную на 8 частей (потому что меток 8) умножаем на итерацию (каждый раз ровно на одно и то 
	// же отрезок двигаемся вперед) т.к i = 1,2,3,....8 // а (int) - это округляем число пикселей до целого
	// все это получем координату по х, а за у взяли уровень х и +-3 пикселя вверх и вниз
	// в итоге у нас две пары координат (х,у) по которым чертим линию
	// и так 8 раз (начинаем с 1, потому что 0 - это ось у, из за того что начинаем с 1, заканчиваем на 9 а не 8;
	
	// в строке Подписи
	// берем ту же длину (длину каждого отрезка), идем обратно 10 пикселей по х, спускемся вниз на 5 пикселей по у
	// и вставляем очередной подпись из массива Ox //" ", "Pi",  "2Pi",....,"8Pi" // первая пуста потому что 0
	
		for (i=0;i<N;i++)  
	{
		// Рисуем график функции
		putpixel(i+X0,NormedResult[i],2); // 2 - это цвт линии графика
		delay(10);	// задежка для красивого вывода
	}
	
	getch();       // Ожидаем нажатия клавиши...
	closegraph();    // Закрываем графичесий режим
	getch();   // Ожидаем нажатия клавиши...
	return 0;
}
