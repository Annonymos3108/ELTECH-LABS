#include <iostream>
#include <stdlib.h>
#include "List.h"
using namespace std;

/* Деструктор — это функция-член, которая вызывается автоматически,
когда объект выходит из области действия или явно уничтожается вызовом Delete */

List::~List()								//Деструктор  
{
	while (Head)							//Пока по адресу на начало списка что-то есть
	{
		Tail = Head->Next;					//Резервная копия адреса следующего звена списка
		delete Head;						//Очистка памяти от первого звена
		Head = Tail;						//Смена адреса начала на адрес следующего элемента
	}
}

void List::AddLast(int x)
{
	Node* temp = new Node;					//Выделение памяти под новый элемент структуры
	temp->Next = NULL;						//Указываем, что изначально по следующему адресу пусто
	temp->x = x;							//Записываем значение в структуру

	if (Head != NULL)						//Если список не пуст
	{
		temp->Prev = Tail;					//Указываем адрес на предыдущий элемент в соотв. поле
		Tail->Next = temp;					//Указываем адрес следующего за хвостом элемента
		Tail = temp;						//Меняем адрес хвоста
	}
	else									//Если список пустой
	{
		temp->Prev = NULL;					//Предыдущий элемент указывает в пустоту
		Head = Tail = temp;					//Голова=Хвост=тот элемент, что сейчас добавили
	}
}

void List::AddFirst(int x)
{
	Node* temp = new Node;					//Выделение памяти под новый элемент структуры
	temp->Prev = NULL;
	temp->x = x;							//Записываем значение в структуру
	if (Head != NULL)
	{
		temp->Next = Head;					//Указываем, что по следующему адресу начало списка
		Head->Prev = temp;						//Указываем адрес педыдущего за началом элемента
		Head = temp;							//Меняем адрес начала
	}
	else
	{
		temp->Next = NULL;
		Head = Tail = temp;
	}
}

void List::DeleteFirst(int x)
{
	//Если удаляем первый элемент, то могут быть такие варианты
	//В списке есть только первый, в списке есть несколько элементов
	//Поэтому разбиваем логику выполнения
	if ((x == 1) and (Head->Next))			//Если удаляем первый, но есть и другие, то
	{
		Node* temp = Head;	                //Указываем, что нам нужно начало списка
		Head = Head->Next;	                //Сдвигаем начало на следующий за началом элемент
		Head->Prev = NULL;	                //Делаем так, чтоб предыдущий началу элемент был пустым
		delete temp;		                //Удаляем удаляемое начало
		return;
	}
	else if ((x == 1) and (Head == Tail))   //Если удаляем первый, но в списке только 1 элемент
	{
		Head->Next = NULL;	                //обнуляем все что нужно
		Head = NULL;
		delete Head;						//Удаляем указатель на начало
		return;
	}
}

void List::DeleteLast(int x)
{
	//удаляемый элемент является последним элементом списка
	Node* temp = Tail;						//Указываем, что нам нужен хвост
	Tail = Tail->Prev;						//Отодвигаем хвост немного назад
	Tail->Next = NULL;						//Обозначаем, что впереди за хвостом пусто
	delete temp;							//Очищаем память от бывшего хвоста                               
}

void List::ShowStart()
{
	//ВЫВОДИМ СПИСОК С НАЧАЛА
	Node* temp = Head;						//Временно указываем на адрес первого элемента
	while (temp != NULL)					//Пока не встретим пустое значение
	{
		cout << temp->x << " ";				//Выводим каждое считанное значение на экран
		temp = temp->Next;					//Смена адреса на адрес следующего элемента
	}
	cout << "\n";
}

void List::ShowEnd()
{
	//ВЫВОДИМ СПИСОК С КОНЦА
	Node* temp = Tail;						//Временный указатель на адрес последнего элемента
	while (temp != NULL)					//Пока не встретится пустое значение
	{
		cout << temp->x << " ";				//Выводить значение на экран
		temp = temp->Prev;					//Указываем, что нужен адрес предыдущего элемента
	}
	cout << "\n";
}

void List::ShowLast()
{
	Node* temp = Tail;				//Временный указатель на адрес последнего элемента
	cout << temp->x;				//Выводить значение на экран
}

void List::ShowFirst()
{
	Node* temp = Head;				//Временный указатель на адрес последнего элемента
	cout << temp->x;				//Выводить значение на экран
}